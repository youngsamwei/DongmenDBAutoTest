<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>201501060136_张欣俣</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>02-exp_01_04_update.c</CENTER></H3><HR>
<PRE>

<A NAME="0"></A>#include &lt;parser/statement.h&gt;


<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#0',2,'match18-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int parseAssignExpr(ParserT *context_parser, arraylist *scope, arraylist *scopeExpr);

sql_stmt_update *parse_sql_stmt_update(ParserT *context_parser) {
    char *DataManager = NULL;
    arraylist *list1 = arraylist_create();
    arraylist *list2 = arraylist_create();
    SRA_t *Context_sra = NULL;

    TokenT *token_word;


    if (!matchToken(context_parser, TOKEN_RESERVED_WORD, &quot;update&quot;)) {
        return NULL;
    }


    token_word = parseNextToken(context_parser);
    if (token_word &amp;&amp; token_word-&gt;type == TOKEN_WORD) {
        DataManager = new_id_name();
        strcpy(DataManager, token_word-&gt;text);
    } else {
        strcpy(context_parser-&gt;parserMessage, &quot;invalid sql: missing table name.&quot;);
        return NULL;
    }

    parseEatAndNextToken(context_parser);


    if (!matchToken(context_parser, TOKEN_RESERVED_WORD, &quot;set&quot;)) {
        return NULL;
    }


    if (!parseAssignExpr(context_parser, list1, list2)) {
        return NULL;
    }


    Context_sra = SRATable(TableRelist2rence_make(DataManager, NULL));
    if (matchToken(context_parser, TOKEN_RESERVED_WORD, &quot;where&quot;)) {
        Expression *expre_pre = parseExpressionRD(parser);
        Context_sra = SRASelect(Context_sra, expre_pre);
    }


    sql_stmt_update *database_updated = (sql_stmt_update *) calloc(sizeof(sql_stmt_update), 1);
    database_updated-&gt;tableName = DataManager;
    database_updated-&gt;scope = list1;
    database_updated-&gt;scopeExpr = list2;
    database_updated-&gt;where = Context_sra;

    return database_updated;
};

int parseAssignExpr(ParserT *context_parser, arraylist *scope, arraylist *scopeExpr) {
    TokenT *token_word = parseNextToken(context_parser);
    while (1) {

        if (token_word == NULL || token_word-&gt;type != TOKEN_WORD) {
            strcpy(context_parser-&gt;parserMessage, &quot;invalid sql: missing field name.&quot;);
            return 0;
        }

        char *flag_type = new_id_name();
        strcpy(flag_type,token_word-&gt;text);
        arraylist_add(scope, flag_type);
        parseEatAndNextToken(context_parser);


        if (!matchToken(context_parser, TOKEN_EQ, &quot;=&quot;)) {
            return 0;
        }


        Expression *context_exp = parseExpressionRD(context_parser);
        if (context_parser-&gt;parserStateType == PARSER_WRONG) {
            strcpy(context_parser-&gt;parserMessage, &quot;invalid sql: invalid expression.&quot;);
            return 0;
        }
        arraylist_add(scopeExpr, context_exp);

        token_word = parseNextToken(context_parser);
        if (token_word == NULL || token_word-&gt;type != TOKEN_COMMA) {
            break;
        }
        token_word = parseEatAndNextToken(context_parser);
    }
    return 1;
};</B></FONT>

</PRE>
<HR>
<H3><CENTER>03-exp_07_05_update.c</CENTER></H3><HR>
<PRE>

#include &quot;physicalplan/physicalplan.h&quot;
<A NAME="1"></A>


<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match18-0.html#1',2,'match18-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>int plan_execute_update(dongmendb *database, sql_stmt_update *database_update , transaction *text_file){

    char *tableName = database_deleted-&gt;tableName;
    arraylist *list1 = database_deleted-&gt;fields;
    arraylist *list2 = database_deleted-&gt;fieldsExpr;

    physical_scan *scansion = physical_scan_generate(database, database_deleted-&gt;where, text_file);
    scansion-&gt;beforeFirst(scansion);
    size_t change_count = 0;

    while (scansion-&gt;next(scansion)) {
        for (size_t i = 0; i &lt; list1-&gt;size; ++i) {
            char *current_directory_name = arraylist_get(list1, i);
            variant *quantity = (variant *) calloc(sizeof(variant), 1);
            enum data_type data_text = scansion-&gt;getField(scansion, tableName, current_directory_name)-&gt;type;
            physical_scan_evaluate_expression(arraylist_get(list2, i), scan, val);

            if (quantity-&gt;type != data_text) {
                fprintf(stdout, &quot;invalid sql: field type mismatched.&quot;);
                return -1;
            }

            if (quantity-&gt;type == DATA_TYPE_INT) {
               scansion-&gt;setInt(scansion, tableName, current_directory_name, quantity-&gt;intValue);
            } else if (quantity-&gt;type == DATA_TYPE_CHAR) {

                int max_length_type = scansion-&gt;getField(scansion, tableName, current_directory_name)-&gt;length;
                if (max_length_type &lt; strlen(val-&gt;strValue)) {
                    quantity-&gt;strValue[max_length_type] = '\0';
                }
                scansion-&gt;setString(scansion, tableName, current_directory_name, quantity-&gt;strValue);
            } else {

            }
        }
        change_count += 1;
    }
   scansion-&gt;close(scansion);
    fprintf(stdout, &quot; updated %d lines.\n&quot;, change_count);

    return change_count;
};</B></FONT>
</PRE>
</BODY>
</HTML>
