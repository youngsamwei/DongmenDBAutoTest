<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>201601060436_赵旭</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>01-exp_01_04_update.c.c</CENTER></H3><HR>
<PRE>
<A NAME="0"></A>/*TODO: parse_sql_stmt_update，：） update的语句解析*/
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match192-0.html#0',2,'match192-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B> sql_stmt_update *parse_sql_stmt_update(ParserT *parser) {
 //    fprintf(stderr, &quot;TODO: update is not implemented yet. in parse_sql_stmt_update \n&quot;);
     char *tableName = NULL;
     arraylist *fields = arraylist_create();
     arraylist *fieldsExpr = arraylist_create();

     TokenT *token = parseNextToken(parser);
     if (!matchToken(parser, TOKEN_RESERVED_WORD, &quot;update&quot;)) { //观察是不是update
         strcpy(parser-&gt;parserMessage, &quot;语法错误.&quot;);
         return NULL;
     }

     token = parseNextToken(parser);
     if (token-&gt;type == TOKEN_WORD) {   // 看是不是非系统关键字
         tableName = new_id_name();
         strcpy(tableName, token-&gt;text);
     } else {
         strcpy(parser-&gt;parserMessage, &quot;invalid sql: missing table name.&quot;);
         return NULL;
     }

     token = parseEatAndNextToken(parser); // 提取下一个词
     if (!matchToken(parser, TOKEN_RESERVED_WORD, &quot;set&quot;)) { // 未匹配set
         strcpy(parser-&gt;parserMessage, &quot;语法错误.&quot;);
         return NULL;
     }

     token = parseNextToken(parser);// 提取下一个词

     while (token != NULL &amp;&amp; (token-&gt;type == TOKEN_WORD || token-&gt;type == TOKEN_COMMA)) {  //如果下一个词非空，且非系统关键字或是逗号
         if (token-&gt;type == TOKEN_COMMA){
             /*如果是逗号，则需要跳过逗号*/
             token = parseEatAndNextToken(parser);
         }
         /*获取字段名称*/
         if (token-&gt;type == TOKEN_WORD) {
             char *fieldName = new_id_name();
             strcpy(fieldName, token-&gt;text);
             arraylist_add(fields, fieldName);

         } else {
             strcpy(parser-&gt;parserMessage, &quot;invalid sql: missing table name.&quot;);
             /*提取出错*/
             return NULL;
         }

         token = parseEatAndNextToken(parser);
         /*字段名后面是等号*/
         if (!matchToken(parser, TOKEN_EQ, &quot;=&quot;)) {
             strcpy(parser-&gt;parserMessage, &quot;invalid sql: missing =.&quot;);
             return NULL;
         }
         /*等号后面是表达式*/
         Expression *expr0 = parseExpressionRD(parser);
         arraylist_add(fieldsExpr, expr0);

         token = parseNextToken(parser);
         if (token == NULL) {
             break;
         }
     }
     Expression *whereExpr = NULL;   //约束变量
     if (token !=NULL) {
         if (!matchToken(parser, TOKEN_RESERVED_WORD, &quot;where&quot;)) {
             strcpy(parser-&gt;parserMessage, &quot;语法错误.&quot;);
             return NULL;
         }
         whereExpr = parseExpressionRD(parser);

         if (parser-&gt;parserStateType == PARSER_WRONG) {
             return NULL;
         }
     }
    /*创建sql_stmt_update指针，存储并返回*/
     sql_stmt_update *sqlStmtUpdate = (sql_stmt_update *) malloc(sizeof(sql_stmt_update));
     sqlStmtUpdate-&gt;tableName = tableName;
     sqlStmtUpdate-&gt;fields = fields;
     sqlStmtUpdate-&gt;fieldsExpr = fieldsExpr;

     TableReference_t *ref =   TableReference_make(tableName, NULL);
     SRA_t *table =  SRATable(ref);
     sqlStmtUpdate-&gt;where = table;
     if (whereExpr != NULL) {
         sqlStmtUpdate-&gt;where = SRASelect(table, whereExpr);
     }

     return sqlStmtUpdate;
 }</B></FONT>
</PRE>
<HR>
<H3><CENTER>03-exp_07_05_update.c.c</CENTER></H3><HR>
<PRE>
//
//
#include &quot;physicalplan/physicalplan.h&quot;

/*执行 update 语句*/
/*TODO: plan_execute_update， update语句执行*/
int plan_execute_update(dongmendb *db, sql_stmt_update *sqlStmtUpdate , transaction *tx){
    /*删除语句以select的物理操作为基础实现。
<A NAME="1"></A>     * 1. 使用 sql_stmt_update 的条件参数，调用 physical_scan_select_create 创建select的物理计划并初始化;
     * 2. 执行 select 的物理计划，完成update操作
     * */
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match192-0.html#1',2,'match192-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    physical_scan *scan = physical_scan_generate(db, sqlStmtUpdate-&gt;where, tx);//创建全表扫描计划
    scan-&gt;beforeFirst(scan);//初始化操作
    while (scan-&gt;next(scan)) {//当还有扫描计划时
        for (size_t i = 0; i &lt; sqlStmtUpdate-&gt;fields-&gt;size; ++i) {  //arraylist *fields; /[表情：0]t fields 被更新的字段列表
            char *currentFieldName = arraylist_get(sqlStmtUpdate-&gt;fields, i);//获取要更新的列名
            Expression *currentFieldsExprName=arraylist_get(sqlStmtUpdate-&gt;fieldsExpr,i);//获取需要更新的值的表达式
            variant *val = (variant *) calloc(sizeof(variant), 1);//保存需要更新的字段类型
            enum data_type field_type = scan-&gt;getField(scan, sqlStmtUpdate-&gt;tableName, currentFieldName)-&gt;type; //获取列名的类型
            physical_scan_evaluate_expression(currentFieldsExprName, scan, val);//计算后序表达式的值

            if (val-&gt;type != field_type) {
                fprintf(stdout, &quot;invalid sql: field type mismatched.&quot;);
                return DONGMENDB_EINVALIDSQL;//1
            }
            if (val-&gt;type == DATA_TYPE_INT) {
                scan-&gt;setInt(scan, sqlStmtUpdate-&gt;tableName, currentFieldName, val-&gt;intValue);
            } else if (val-&gt;type == DATA_TYPE_CHAR) {
                scan-&gt;setString(scan, sqlStmtUpdate-&gt;tableName, currentFieldName, val-&gt;strValue);
            }
        }</B></FONT>
    }
    scan-&gt;close(scan);
    return DONGMENDB_OK;//0
};
</PRE>
</BODY>
</HTML>
