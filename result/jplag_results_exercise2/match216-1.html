<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>201601060412_李兆玉</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff" style="margin-left:25">
<HR>
<H3><CENTER>02-exp_01_04_update.c</CENTER></H3><HR>
<PRE>
#include &lt;parser/statement.h&gt;

/**
 * 在现有实现基础上，实现update from子句
 *
 * 支持的update语法：
 *
 * UPDATE &lt;table_name&gt; SET &lt;field1&gt; = &lt;expr1&gt;[, &lt;field2 = &lt;expr2&gt;, ..]
 * WHERE &lt;logical_expr&gt;
 * update student SET name = 'xiaowang'
 * UPDATE Person SET Address = 'Zhongshan 23', City = 'Nanjing' WHERE LastName = 'Wilson'
 *
 * 解析获得 sql_stmt_update 结构
 */
<A NAME="0"></A>
/*TODO: parse_sql_stmt_update， update语句解析*/
sql_stmt_update *parse_sql_stmt_update(ParserT *parser)
<FONT color="#0000ff"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match216-0.html#0',2,'match216-top.html#0',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>{
    char *tableName=NULL;
    arraylist *fieldsExpr=arraylist_create();arraylist *fields=arraylist_create();
    TokenT *token=parseNextToken(parser);//创建token，获取列名时第一次使用,获取token判断表名
    if(!matchToken(parser,TOKEN_RESERVED_WORD,&quot;update&quot;))
    {
        strcpy(parser-&gt;parserMessage,&quot;语法错误.&quot;);
        return NULL;
    }</B></FONT>
    //不执行功能
    for(int i=0;i&lt;1;i++){
        int tmp=0;
        for(int j=2;j&lt;=3;j++)
            ++tmp;
    }
    token=parseNextToken(parser);
    //获取表名，否则输出未获得
    if(token-&gt;type==TOKEN_WORD)
    {
        tableName=new_id_name();
        strcpy(tableName,token-&gt;text);
        //不执行功能
        for(int i=0;i&lt;1;i++){
            int tmp=0;
<A NAME="1"></A>            for(int j=2;j&lt;=3;j++)
                ++tmp;
        }
<FONT color="#f63526"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match216-0.html#1',2,'match216-top.html#1',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    }
    else
    {
        strcpy(parser-&gt;parserMessage,&quot;invalid sql: missing table name.&quot;);
        return NULL;
    }
    token=parseEatAndNextToken(parser);
    if(!matchToken(parser,TOKEN_RESERVED_WORD,&quot;set&quot;)) {
        strcpy(parser-&gt;parserMessage,&quot;语法错误.&quot;);
        return NULL;
    }
    token=parseNextToken(parser);
    while(token != NULL &amp;&amp; (token-&gt;type==TOKEN_WORD||token-&gt;type==TOKEN_COMMA))
    {
        if(token-&gt;type==TOKEN_COMMA)
        {
            //token_comma判断逗号，是就去掉并获取下一个字段
            token = parseEatAndNextToken(parser);
        }
        if(token-&gt;type==TOKEN_WORD)
        {//获取要修改的属性列
            char *fieldName=new_id_name();</B></FONT>
            strcpy(fieldName,token-&gt;text);
            arraylist_add(fields,fieldName);
            //不执行功能
            for(int i=0;i&lt;1;i++){
                int tmp=0;
<A NAME="2"></A>                for(int j=2;j&lt;=3;j++)
                    ++tmp;
            }
<FONT color="#77bfc7"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match216-0.html#2',2,'match216-top.html#2',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>        }
        else
        {
            strcpy(parser-&gt;parserMessage,&quot;invalid sql: missing fields name.&quot;);
            return NULL;
        }
        token=parseEatAndNextToken(parser);
        if(!matchToken(parser, TOKEN_EQ, &quot;=&quot;))
        {//判断等号去掉，下一个
            strcpy(parser-&gt;parserMessage,&quot;invalid sql: missing =.&quot;);
            return NULL;
        }
        Expression *expr0=parseExpressionRD(parser);
        arraylist_add(fieldsExpr,expr0);
        token=parseNextToken(parser);
        if(token==NULL)
        {
            break;
        }
    }
    Expression *whereExpr = NULL;
    if(token!=NULL)
    {
        if(!matchToken(parser,TOKEN_RESERVED_WORD, &quot;where&quot;))
        {
            strcpy(parser-&gt;parserMessage,&quot;语法错误.&quot;);
            return NULL;
        }
        whereExpr=parseExpressionRD(parser);
        if(parser-&gt;parserStateType==PARSER_WRONG)
        {
            return NULL;
        }
    }
    sql_stmt_update *sqlstmtUpdate=(sql_stmt_update *)malloc(sizeof(sql_stmt_update));
    sqlstmtUpdate-&gt;tableName=tableName;
    sqlstmtUpdate-&gt;fields=fields;
    sqlstmtUpdate-&gt;fieldsExpr=fieldsExpr;
    TableReference_t *reff=TableReference_make(tableName, NULL);
    SRA_t *t=SRATable(reff);
    sqlstmtUpdate-&gt;where = t;
    if(whereExpr!=NULL)
    {
        sqlstmtUpdate-&gt;where=SRASelect(t,whereExpr);
    }
    return sqlstmtUpdate;
};</B></FONT>
</PRE>
<HR>
<H3><CENTER>03-exp_07_05_update.c</CENTER></H3><HR>
<PRE>
#include &quot;physicalplan/physicalplan.h&quot;
int plan_execute_update(dongmendb *db, sql_stmt_update *sqlStmtUpdate , transaction *tx) {
    physical_scan *pplan = physical_scan_generate(db, sqlStmtUpdate-&gt;where, tx);

       pplan-&gt;beforeFirst(pplan);//定义计数器，update执行的次数
<A NAME="3"></A>    
	  int count=0;

<FONT color="#6cc417"><div style="position:absolute;left:0"><A HREF="javascript:ZweiFrames('match216-0.html#3',2,'match216-top.html#3',1)"><IMG SRC="back.gif" ALT="other" BORDER="0" ALIGN="left"></A></div><B>    while(pplan-&gt;next(pplan))//循环
    {
        ++count;
        for(size_t j=0; j&lt;sqlStmtUpdate-&gt;fields-&gt;size; j++ )
		{
            char *fieldname=arraylist_get(sqlStmtUpdate-&gt;fields,j);
            variant *vvar=malloc(sizeof(variant));
            physical_scan_evaluate_expression(arraylist_get(sqlStmtUpdate-&gt;fieldsExpr,j),pplan,vvar);
            if(vvar-&gt;type == DATA_TYPE_INT)
			{
                pplan-&gt;setInt(pplan,sqlStmtUpdate-&gt;tableName,fieldname,vvar-&gt;intValue);
            }
            else if( vvar-&gt;type == DATA_TYPE_CHAR)
			{
                pplan-&gt;setString(pplan,sqlStmtUpdate-&gt;tableName,fieldname,vvar-&gt;strValue);
            }
        }
    }
    pplan-&gt;close(pplan);
    return count;//返回次数
};</B></FONT>
</PRE>
</BODY>
</HTML>
