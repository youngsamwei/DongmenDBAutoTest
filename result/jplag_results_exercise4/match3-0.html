<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<HTML>
<HEAD>
 <TITLE>201601060425_王兆发</TITLE>
<META http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <script type="text/javascript">
  <!--
   function ZweiFrames(URL1,F1,URL2,F2)
   {
    parent.frames[F1].location.href=URL1;
    parent.frames[F2].location.href=URL2;
   }
  //-->
  </script>
</HEAD>
<BODY BGCOLOR="#ffffff">
<HR>
<H3><CENTER>01-exp_05_02_condition_push_down.c</CENTER></H3><HR>
<PRE>
//
// Created by Sam on 2018/2/13.
//

<A NAME="0"></A>#include &lt;dongmensql/optimizer.h&gt;


<FONT color="#0000ff"><A HREF="javascript:ZweiFrames('match3-1.html#0',3,'match3-top.html#0',1)"><IMG SRC="forward.gif" ALT="other" BORDER="0" ALIGN="right"></A><B>int opt_expr_test(Expression *expr) {
    /*term不为空，则表示expr是term，可以终止*/
    if (expr-&gt;term != NULL) {
        return 0;
    } else if (expr-&gt;opType == TOKEN_AND) {
        return 1;
    }
    return 0;
}

SRA_t *dongmendb_condition_change(SRA_t *sra)
{
    switch (sra-&gt;t) {
        case SRA_SELECT: {</B></FONT>
            /*检查关系代数表达式中的select是否存在多个and条件串接的情况
            * 若存在，返回1
            * 若不存在，返回0*/

            //获取select和表达式cond
            SRA_Select_t select = sra-&gt;select;
            SRA_t *nextPoint = sra-&gt;select.sra;
            Expression *expr = select.cond;

            //设定链表指针与表尾指针
            SRA_t *changeSelect = NULL;
            SRA_t *pChangeSelect = NULL;

            //判断cond是否为合取范式
            int ret = opt_expr_test(expr);

            //对合取范式进行串接
            if(ret)
            {
                int num = 0;                    //定义为条件数
                int flag = 1;                   //定义为EQ检测标记
                int eFlag = 1;
                Expression *fE = expr;          //表达式前指针
                Expression *pByExpr = expr;     //表达式尾指针的父节点指针

                //表达式尾指针不为空时下行
                while(expr)
                {
                    //每检测到一个TOKEN_AND证明表达式数量+1
                    if(expr-&gt;opType == TOKEN_AND)
                        num++;
                    else if((expr-&gt;opType == TOKEN_LT || expr-&gt;opType == TOKEN_GT || expr-&gt;opType == TOKEN_EQ || expr-&gt;opType == TOKEN_NOT_EQUAL || expr-&gt;opType == TOKEN_LE || expr-&gt;opType == TOKEN_GE) &amp;&amp; num)
                    {
                        //检测到比较运算符使用fE进行标记

                        if(flag)                        //fE指针移位标记
                            flag = 0;
                        else                            //在检测到EQ
                        {
                            if(eFlag)
                            {
                                sra-&gt;select.cond = fE;                //赋值选择条件
                                sra-&gt;t = SRA_SELECT;                  //指定SRA类型
                                fE = expr;
                                pByExpr-&gt;nextexpr = NULL;
                                pByExpr = expr;

                                num--;
                                eFlag = 0;
                            }
                            else
                            {
                                //创建SRA节点并赋值
                                SRA_t *p = malloc(sizeof(SRA_t));
                                p-&gt;select.sra = NULL;
                                p-&gt;select.cond = fE;                //赋值选择条件
                                p-&gt;t = SRA_SELECT;                  //指定SRA类型
                                fE = expr;
                                pByExpr-&gt;nextexpr = NULL;
                                pByExpr = expr;

                                if(!changeSelect)
                                {
                                    changeSelect = p;
                                    pChangeSelect = p;
                                }
                                else
                                {
                                    pChangeSelect-&gt;select.sra = p;
                                    pChangeSelect = pChangeSelect-&gt;select.sra;
                                }


                                num--;
                            }

                        }
                    }


                    if(!expr-&gt;nextexpr)
                    {
                        SRA_t *p = malloc(sizeof(SRA_t));
                        p-&gt;select.sra = NULL;
                        p-&gt;select.cond = fE;
                        p-&gt;t = SRA_SELECT;

                        if(!changeSelect)
                        {
                            changeSelect = p;
                            pChangeSelect = p;
                        }
                        else
                        {
                            pChangeSelect-&gt;select.sra = p;
                            pChangeSelect = pChangeSelect-&gt;select.sra;
                        }
                    }

                    if(flag)
                        fE = fE-&gt;nextexpr;
                    if(pByExpr != expr)
                        pByExpr = pByExpr-&gt;nextexpr;
                    expr = expr-&gt;nextexpr;
                }

                //将原先的SRASelect替换为串接的SRASelect
                pChangeSelect-&gt;select.sra = nextPoint;
                sra-&gt;select.sra  = changeSelect;
            }


            //向下搜索剩余的语法树中的SRASelect
            dongmendb_condition_change(sra-&gt;select.sra);
        };
        case SRA_TABLE: {
            return sra;
        }
        case SRA_JOIN: {

            dongmendb_condition_change(sra-&gt;join.sra1);
            dongmendb_condition_change(sra-&gt;join.sra2);

        }
        case SRA_PROJECT:
            dongmendb_condition_change(sra-&gt;project.sra);
    }
}

/**
 * 使用关于选择的等价变换规则将条件下推。
 *
 */


/*输入一个关系代数表达式，输出优化后的关系代数表达式
 * 要求：在查询条件符合合取范式的前提下，根据等价变换规则将查询条件移动至合适的位置。
 * */
SRA_t *dongmengdb_algebra_optimize_condition_pushdown(SRA_t *sra, table_manager *tableManager, transaction *tx){

    /*初始关系代数语法树sra由三个操作构成：SRA_PROJECT -&gt; SRA_SELECT -&gt; SRA_JOIN，即对应语法树中三个节点。*/

    /*第一步：.等价变换：将SRA_SELECT类型的节点进行条件串接*/

        /*1.1 在sra中找到每个SRA_Select节点 */
        /*1.2 检查每个SRA_Select节点中的条件是不是满足串接条件：多条件且用and连接*/
        /*1.3 若满足串接条件则：创建一组新的串接的SRA_Select节点，等价替换当前的SRA_Select节点*/

    /*第二步：等价变换：条件交换*/
        /*2.1 在sra中找到每个SRA_Select节点*/
        /*2.2 对每个SRA_Select节点做以下处理：
         * 在sra中查找 SRA_Select 节点应该在的最优位置：
         *     若子操作也是SRA_Select，则可交换；
         *     若子操作是笛卡尔积，则可交换，需要判断SRA_Select所包含的属性属于笛卡尔积的哪个子操作
         * 最后将SRA_Select类型的节点移动到语法树的最优位置。
         * */



    //将SRA_SELECT类型的节点进行条件串接
    dongmendb_condition_change(sra);


    return sra;
}
</PRE>
</BODY>
</HTML>
